%% x := y + z 

INTEGER x ;
INTEGER y ;
INTEGER z ;


y = 99 + 3 ;
z = 1 ;

w = 89 ;

x = y + z ;



IF ( x + 5 < 9 ) { ff = 8 ; } END_IF ; 

IF ( x + 5 < 9 ) { INTEGER fff ; fff = 8 ; } END_IF ; 



IF ( ww > 0 ) { 
	IF ( b > 8 ) { 
		y = b ; 
	} END_IF ; 
	
	INTEGER k ; 
	k = k * y ; 
} ELSE { 
	INTEGER j ; 
	j = j - 3 ; 
} END_IF ;


%%aca hay un error! no desapila ambito!
IF ( ww > 0 ) { 
	INTEGER k ; 
	k = k * y ; 
} ELSE { 
	IF ( b > 8 ) { 
		y = b ; 
	} END_IF ; 
	
	INTEGER j ; 
	j = j - 3 ; 
} END_IF ;




INTEGER a ;
a = 5 ;

INTEGER b ;
b = 8 ;

IF ( a - b > c + 1 ) { a = b + c ; } ELSE { a = b - c ; } END_IF ;



LOOP { a = b + c ; c = d - 3 ; } UNTIL ( a + b > c - d ) ;



%%en la generacion de codigo assembler falta CALL y RET cuando finaliza

PROC proced ( INTEGER m ) NI = 2 { yyy = 99 + m ; } ;


PROC f1 ( INTEGER x , REF FLOAT y , FLOAT z ) NI = 2 { 
	x = y + z ; 
	INTEGER f1a ;
	f1a = 100 ;
		
	} ;


proced ( a : x ) ;  %%asi invoca bien. falta la semantica de la invocacion
			
			